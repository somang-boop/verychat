"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.loginCommand = loginCommand;
const http = __importStar(require("node:http"));
const url = __importStar(require("node:url"));
const node_child_process_1 = require("node:child_process");
const config_js_1 = require("../lib/config.js");
const logger = __importStar(require("../lib/logger.js"));
function openBrowser(url) {
    const platform = process.platform;
    const cmd = platform === "darwin"
        ? "open"
        : platform === "win32"
            ? "start"
            : "xdg-open";
    (0, node_child_process_1.exec)(`${cmd} "${url}"`);
}
function findFreePort() {
    return new Promise((resolve, reject) => {
        const server = http.createServer();
        server.listen(0, () => {
            const addr = server.address();
            if (addr && typeof addr === "object") {
                const port = addr.port;
                server.close(() => resolve(port));
            }
            else {
                reject(new Error("Failed to find free port"));
            }
        });
    });
}
async function loginCommand(options) {
    const serverURL = (options.server || config_js_1.DEFAULT_SERVER_URL).replace(/\/+$/, "");
    const provider = options.github ? "github" : "google";
    const port = await findFreePort();
    const spin = logger.spinner("Waiting for browser authentication...");
    // Start temporary HTTP server to receive OAuth callback
    const tokenPromise = new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
            server.close();
            reject(new Error("Authentication timed out (30s)"));
        }, 30000);
        const server = http.createServer((req, res) => {
            const parsed = url.parse(req.url || "", true);
            if (parsed.pathname === "/callback") {
                const accessToken = parsed.query.access_token;
                const refreshToken = parsed.query.refresh_token;
                if (accessToken && refreshToken) {
                    res.writeHead(200, { "Content-Type": "text/html" });
                    res.end(`
              <html>
                <body style="font-family: system-ui, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #0a0a0a; color: #fafafa;">
                  <div style="text-align: center;">
                    <h2>Authentication Successful</h2>
                    <p>You can close this window and return to the terminal.</p>
                  </div>
                </body>
              </html>
            `);
                    clearTimeout(timeout);
                    server.close();
                    resolve({ access_token: accessToken, refresh_token: refreshToken });
                }
                else {
                    res.writeHead(400, { "Content-Type": "text/html" });
                    res.end(`
              <html>
                <body style="font-family: system-ui, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #0a0a0a; color: #fafafa;">
                  <div style="text-align: center;">
                    <h2>Authentication Failed</h2>
                    <p>Missing tokens. Please try again.</p>
                  </div>
                </body>
              </html>
            `);
                    clearTimeout(timeout);
                    server.close();
                    reject(new Error("Missing tokens in callback"));
                }
            }
            else {
                res.writeHead(404);
                res.end("Not Found");
            }
        });
        server.listen(port, () => {
            const authURL = `${serverURL}/api/auth/${provider}?cli_port=${port}`;
            logger.info(`Opening browser for ${provider} login...`);
            openBrowser(authURL);
        });
    });
    try {
        const tokens = await tokenPromise;
        // Create API key using the access token
        const keyResp = await fetch(`${serverURL}/api/settings/api-keys`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${tokens.access_token}`,
            },
            body: JSON.stringify({ name: "CLI Key" }),
        });
        if (!keyResp.ok) {
            throw new Error("Failed to create API key");
        }
        const keyData = (await keyResp.json());
        const apiKey = keyData.data.key;
        // Get user email
        const meResp = await fetch(`${serverURL}/api/auth/me`, {
            headers: { Authorization: `Bearer ${tokens.access_token}` },
        });
        const meData = (await meResp.json());
        const userEmail = meData.data.email;
        // Save config
        (0, config_js_1.saveConfig)({
            server_url: serverURL,
            api_key: apiKey,
            user_email: userEmail,
        });
        spin.stop();
        logger.success(`Logged in as ${logger.bold(userEmail)}`);
        // Register MCP server
        const mcpRegistered = (0, config_js_1.registerMCP)();
        if (mcpRegistered) {
            logger.success("Claude Code MCP server registered");
            logger.dim('Claude Code를 재시작하면 "배포해줘"로 바로 배포할 수 있습니다.');
        }
    }
    catch (err) {
        spin.stop();
        logger.error(`Login failed: ${err.message}`);
        process.exit(1);
    }
}
